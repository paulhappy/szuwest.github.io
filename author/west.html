<!DOCTYPE html>
<head>
    <meta charset="utf-8" />
    <!-- Set the viewport width to device width for mobile -->
    <meta name="viewport" content="width=device-width" />

    <title>West's blog - West</title>

    <link rel="stylesheet" href="http://szuwest.github.io/theme/css/normalize.css" />
    <link rel="stylesheet" href="http://szuwest.github.io/theme/css/foundation.min.css" />
    <link rel="stylesheet" href="http://szuwest.github.io/theme/css/style.css" />
    <link rel="stylesheet" href="http://szuwest.github.io/theme/css/pygments.css" />	
    <script src="http://szuwest.github.io/theme/js/custom.modernizr.js"></script>

    <!-- So Firefox can bookmark->"abo this site" -->

</head>

<body>

<!-- Nav Bar -->
<nav>
<div class="top-bar">
<div class="row">
    <div class="large-9 large-centered columns">
	    <h1><a href="http://szuwest.github.io">West's blog</a></h1>
    </div>
</div>
</div>

<!-- Show menu items and pages -->
<div class="row">
<div class="large-9 columns">
    <ul class="button-group navigation">

    </ul>
</div>
</div>
</nav>
<!-- End Nav -->


<!-- Main Page Content and Sidebar -->
<div class="row">

    <!-- Main Blog Content -->
    <div class="large-9 columns">
        
        

            <article>
                <a href="http://szuwest.github.io/react-nativekuang-jia-yuan-ma-xue-xi-iosshang.html"><h3 class="article-title">react-native框架源码学习(iOS)(上)</h3></a>
<h6 class="subheader" title="2018-02-26T00:00:00">2018-02-26
</h6>


<h1>react-native框架源码学习(iOS)(上)</h1>
<h2>注意事项</h2>
<p>要学习react-native框架iOS端源码，先要了解一下注意的事项。</p>
<ul>
<li>一、 首先需要非常熟悉objective-c语言，对OC的runtime机制更是必不可少。源码里大量用了runtime特性。然后也要熟悉c++语言。除了OC语言，里面还有大量的c++代码，OC与c++混合代码。对c++的template和std库也要熟悉。我本人对c++也熟悉，但是不够深入，对一些高级特性不是很了解，所以相关的一些代码看起来很吃力。最后当然也熟悉js语言。我大学时学习过js，但是那还真是远古时代了，js近年来发展很快，我对很多新特性不是很了解，这也对我学习有一定的阻碍。另外还有要比较了解iOS的JavaScriptCore框架，这个是js与OC通信的基础。</li>
<li>二、 要对react-native的版本了解。查看网上的资料时也要注意他们所说的RN版本。现在网上很多研究资料，他们所研究的版本都是很早之前的版本。新的版本跟老版本有很多细节和流程改变了。如果你发现有些文章里说的东西跟你所看到的对不上，那就是研究的版本不一致。</li>
<li>三、如果看不懂，多看看别人的分析文章。如果对某种语言或者框架库不熟悉，建议先把该补的补上。</li>
</ul>
<p>我所研究的RN版本是<strong>0.49</strong>，而最新版是0.51. 最后我自己也不敢说自己完全看懂了源码，自己的理解完全正确，所以下面所说的也不一定完全正确。</p>
<h2>核心原理</h2>
<p>主要原理利用JavaScriptCore的通信机制来做一些基本的js和OC相互调用，但是RN还做了更多事情。
OC会将所有要暴露给JS调用的方法和属性生成一个配置表，然后会将这个配置表写入到JS端。RN中OC和JS都分别有一个桥接对象，他们相互调用都是通过这个桥接对象进行。
RN大致结构图：
<img alt="RN结构图" src="https://upload-images.jianshu.io/upload_images/1271831-7ba4d20000946a6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" /></p>
<h2>启动流程</h2>
<p>研究源码当然得从启动流程开始。新建一个RN工程，它的AppDelagte入口方法代码大致如下：</p>
<div class="highlight"><pre><span class="k">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">application:</span><span class="p">(</span><span class="n">UIApplication</span> <span class="o">*</span><span class="p">)</span><span class="nv">application</span> <span class="nf">didFinishLaunchingWithOptions:</span><span class="p">(</span><span class="n">NSDictionary</span> <span class="o">*</span><span class="p">)</span><span class="nv">launchOptions</span>
<span class="p">{</span>

  <span class="n">NSURL</span> <span class="o">*</span><span class="n">jsCodeLocation</span><span class="p">;</span>

  <span class="n">jsCodeLocation</span> <span class="o">=</span> <span class="p">[[</span><span class="n">RCTBundleURLProvider</span> <span class="n">sharedSettings</span><span class="p">]</span> <span class="n">jsBundleURLForBundleRoot</span><span class="o">:</span><span class="s">@&quot;index.ios&quot;</span> <span class="n">fallbackResource</span><span class="o">:</span><span class="nb">nil</span><span class="p">];</span>

  <span class="n">RCTRootView</span> <span class="o">*</span><span class="n">rootView</span> <span class="o">=</span> <span class="p">[[</span><span class="n">RCTRootView</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">initWithBundleURL</span><span class="o">:</span><span class="n">jsCodeLocation</span>
                                                      <span class="nl">moduleName:</span><span class="s">@&quot;VprScene&quot;</span>
                                               <span class="nl">initialProperties:</span><span class="nb">nil</span>
                                                   <span class="nl">launchOptions:</span><span class="n">launchOptions</span><span class="p">];</span>
  <span class="n">rootView</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UIColor</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">initWithRed</span><span class="o">:</span><span class="mf">0.0</span><span class="o">/</span><span class="mi">255</span> <span class="n">green</span><span class="o">:</span><span class="mf">0.0</span><span class="o">/</span><span class="mi">255</span> <span class="n">blue</span><span class="o">:</span><span class="mf">0.0</span><span class="o">/</span><span class="mi">255</span> <span class="n">alpha</span><span class="o">:</span><span class="mi">1</span><span class="p">];</span>

  <span class="n">self</span><span class="p">.</span><span class="n">window</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UIWindow</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">initWithFrame</span><span class="o">:</span><span class="p">[</span><span class="n">UIScreen</span> <span class="n">mainScreen</span><span class="p">].</span><span class="n">bounds</span><span class="p">];</span>
  <span class="n">UIViewController</span> <span class="o">*</span><span class="n">rootViewController</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIViewController</span> <span class="n">new</span><span class="p">];</span>
  <span class="n">rootViewController</span><span class="p">.</span><span class="n">view</span> <span class="o">=</span> <span class="n">rootView</span><span class="p">;</span>
  <span class="n">self</span><span class="p">.</span><span class="n">window</span><span class="p">.</span><span class="n">rootViewController</span> <span class="o">=</span> <span class="n">rootViewController</span><span class="p">;</span>
  <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">window</span> <span class="n">makeKeyAndVisible</span><span class="p">];</span>

  <span class="k">return</span> <span class="nb">YES</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>最主要的代码就是初始化了RCTRootView，别的都是普通的代码。也就是说由RCTRootView来进行整个RN的初始化。</p>
<p>RCTRootView的initWithBundleURL:方法中初始化了一个RCTBridge，RCTBridge的初始化方法里调用了一个setUp方法，在这里又初始化了一个RCTCxxBridge（早期版本是RCTBatchedBridge，它们都是RCTBridge的子类）对象，然后调用了它的start方法。这是个关键方法。RCTBridge与RCTCxxBridge类似一个代理模式，RCTBridge提供了对外接口，实际上调用了RCTCxxBridge的实现。这样的好处是方便替换内部实现，而接口保持稳定。</p>
<p>RCTCxxBridge的start方法(为了方便理解，删掉了不必要的代码):</p>
<div class="highlight"><pre><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">start</span>
<span class="p">{</span>
  <span class="p">......</span>

  <span class="c1">// Set up the JS thread early</span>
  <span class="n">_jsThread</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSThread</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">initWithTarget</span><span class="o">:</span><span class="p">[</span><span class="n">self</span> <span class="n">class</span><span class="p">]</span>
                                      <span class="nl">selector:</span><span class="k">@selector</span><span class="p">(</span><span class="n">runRunLoop</span><span class="p">)</span>
                                        <span class="nl">object:</span><span class="nb">nil</span><span class="p">];</span>
  <span class="n">_jsThread</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">RCTJSThreadName</span><span class="p">;</span>
  <span class="n">_jsThread</span><span class="p">.</span><span class="n">qualityOfService</span> <span class="o">=</span> <span class="n">NSOperationQualityOfServiceUserInteractive</span><span class="p">;</span>
  <span class="p">[</span><span class="n">_jsThread</span> <span class="n">start</span><span class="p">];</span>

  <span class="kt">dispatch_group_t</span> <span class="n">prepareBridge</span> <span class="o">=</span> <span class="n">dispatch_group_create</span><span class="p">();</span>

  <span class="p">[</span><span class="n">self</span> <span class="n">registerExtraModules</span><span class="p">];</span>
  <span class="c1">// Initialize all native modules that cannot be loaded lazily</span>
  <span class="p">[</span><span class="n">self</span> <span class="n">_initModules</span><span class="o">:</span><span class="n">RCTGetModuleClasses</span><span class="p">()</span> <span class="n">withDispatchGroup</span><span class="o">:</span><span class="n">prepareBridge</span> <span class="n">lazilyDiscovered</span><span class="o">:</span><span class="nb">NO</span><span class="p">];</span>

  <span class="c1">// This doesn&#39;t really do anything.  The real work happens in initializeBridge.</span>
  <span class="n">_reactInstance</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="n">new</span> <span class="n">Instance</span><span class="p">);</span>

  <span class="n">__weak</span> <span class="n">RCTCxxBridge</span> <span class="o">*</span><span class="n">weakSelf</span> <span class="o">=</span> <span class="n">self</span><span class="p">;</span>

  <span class="c1">// Prepare executor factory (shared_ptr for copy into block)</span>
  <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">JSExecutorFactory</span><span class="o">&gt;</span> <span class="n">executorFactory</span><span class="p">;</span>
  <span class="p">.....</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">executorFactory</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">BOOL</span> <span class="n">useCustomJSC</span> <span class="o">=</span>
        <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">delegate</span> <span class="n">respondsToSelector</span><span class="o">:</span><span class="k">@selector</span><span class="p">(</span><span class="n">shouldBridgeUseCustomJSC</span><span class="o">:</span><span class="p">)]</span> <span class="o">&amp;&amp;</span>
        <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">delegate</span> <span class="n">shouldBridgeUseCustomJSC</span><span class="o">:</span><span class="n">self</span><span class="p">];</span>
      <span class="c1">// The arg is a cache dir.  It&#39;s not used with standard JSC.</span>
      <span class="n">executorFactory</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="n">new</span> <span class="n">JSCExecutorFactory</span><span class="p">(</span><span class="n">folly</span><span class="o">::</span><span class="n">dynamic</span><span class="o">::</span><span class="n">object</span>
        <span class="p">(</span><span class="s">&quot;OwnerIdentity&quot;</span><span class="p">,</span> <span class="s">&quot;ReactNative&quot;</span><span class="p">)</span>
        <span class="p">(</span><span class="s">&quot;UseCustomJSC&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">bool</span><span class="p">)</span><span class="n">useCustomJSC</span><span class="p">)</span>
      <span class="p">));</span>
    <span class="p">}</span>
  <span class="p">......</span>
  <span class="c1">// Dispatch the instance initialization as soon as the initial module metadata has</span>
  <span class="c1">// been collected (see initModules)</span>
  <span class="n">dispatch_group_enter</span><span class="p">(</span><span class="n">prepareBridge</span><span class="p">);</span>
  <span class="p">[</span><span class="n">self</span> <span class="n">ensureOnJavaScriptThread</span><span class="o">:^</span><span class="p">{</span>
    <span class="p">[</span><span class="n">weakSelf</span> <span class="n">_initializeBridge</span><span class="o">:</span><span class="n">executorFactory</span><span class="p">];</span>
    <span class="n">dispatch_group_leave</span><span class="p">(</span><span class="n">prepareBridge</span><span class="p">);</span>
  <span class="p">}];</span>

    <span class="p">.....</span>
    <span class="c1">// Load the source asynchronously, then store it for later execution.</span>
    <span class="n">dispatch_group_enter</span><span class="p">(</span><span class="n">prepareBridge</span><span class="p">);</span>
    <span class="n">__block</span> <span class="n">NSData</span> <span class="o">*</span><span class="n">sourceCode</span><span class="p">;</span>
    <span class="p">[</span><span class="n">self</span> <span class="n">loadSource</span><span class="o">:^</span><span class="p">(</span><span class="n">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">,</span> <span class="n">RCTSource</span> <span class="o">*</span><span class="n">source</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">[</span><span class="n">weakSelf</span> <span class="n">handleError</span><span class="o">:</span><span class="n">error</span><span class="p">];</span>
      <span class="p">}</span>

      <span class="n">sourceCode</span> <span class="o">=</span> <span class="n">source</span><span class="p">.</span><span class="n">data</span><span class="p">;</span>
      <span class="n">dispatch_group_leave</span><span class="p">(</span><span class="n">prepareBridge</span><span class="p">);</span>
    <span class="p">}</span> <span class="n">onProgress</span><span class="o">:^</span><span class="p">(</span><span class="n">RCTLoadingProgress</span> <span class="o">*</span><span class="n">progressData</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">.....</span>
    <span class="p">}];</span>

    <span class="c1">// Wait for both the modules and source code to have finished loading</span>
    <span class="n">dispatch_group_notify</span><span class="p">(</span><span class="n">prepareBridge</span><span class="p">,</span> <span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="n">QOS_CLASS_USER_INTERACTIVE</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="o">^</span><span class="p">{</span>
      <span class="n">RCTCxxBridge</span> <span class="o">*</span><span class="n">strongSelf</span> <span class="o">=</span> <span class="n">weakSelf</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">sourceCode</span> <span class="o">&amp;&amp;</span> <span class="n">strongSelf</span><span class="p">.</span><span class="n">loading</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">[</span><span class="n">strongSelf</span> <span class="n">executeSourceCode</span><span class="o">:</span><span class="n">sourceCode</span> <span class="n">sync</span><span class="o">:</span><span class="nb">NO</span><span class="p">];</span>
      <span class="p">}</span>
    <span class="p">});</span>
<span class="p">.....</span>
<span class="p">}</span>
</pre></div>


<p>这个方法很复杂，主要做了以下内容：</p>
<ul>
<li>创建并开启了一个js线程，绑定了一个runloop，也即是说js代码都是在这个线程里执行。</li>
<li>准备所有要暴露给js调用的OC类,ModuleClass，为每个类封装到RCTModuleData里，如果需要在主线程中是创建某些类的实例，则会在主线程中去创建它。这些RCTModuleData会分别存储在一个字典和数组里。</li>
<li>准备JS运行环境，初始化JSExecutorFactory，并在js线程中创建js的RCTMessageThread，初始化_reactInstance（Instance，这是native跟jsBridge的桥梁）和JSCExecutor</li>
<li>加载JS源码</li>
<li>以上全做完之后，执行JS源码</li>
</ul>
<p>注意代码里用到一个叫prepareBridge的dispatch_group_t，dispatch_group_t主要是用来做异步代码同步用的。有很多初始化工作是异步并行的，运行源码肯定是在所有准备工作之后才能进行，所以用了dispatch_group_t和dispatch_group_notify机制来确保这个问题。接下来我们逐步去分析上面说的几个事情。</p>
<h3>JS线程</h3>
<p>大家常说JavaScript是单线程的，在RN里就是这样的。它创建了一个线程，然后绑定到了一个runloop，然后JS就是在这个线程里执行。在RCTCxxBridge里专门有个方法将block放在JS线程中执行</p>
<div class="highlight"><pre><span class="cm">/**</span>
<span class="cm"> * Ensure block is run on the JS thread. If we&#39;re already on the JS thread, the block will execute synchronously.</span>
<span class="cm"> * If we&#39;re not on the JS thread, the block is dispatched to that thread. Any errors encountered while executing</span>
<span class="cm"> * the block will go through handleError:</span>
<span class="cm"> */</span>
<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">ensureOnJavaScriptThread:</span><span class="p">(</span><span class="kt">dispatch_block_t</span><span class="p">)</span><span class="nv">block</span>
<span class="p">{</span>
  <span class="n">RCTAssert</span><span class="p">(</span><span class="n">_jsThread</span><span class="p">,</span> <span class="s">@&quot;This method must not be called before the JS thread is created&quot;</span><span class="p">);</span>

  <span class="c1">// This does not use _jsMessageThread because it may be called early before the runloop reference is captured</span>
  <span class="c1">// and _jsMessageThread is valid. _jsMessageThread also doesn&#39;t allow us to shortcut the dispatch if we&#39;re</span>
  <span class="c1">// already on the correct thread.</span>

  <span class="k">if</span> <span class="p">([</span><span class="n">NSThread</span> <span class="n">currentThread</span><span class="p">]</span> <span class="o">==</span> <span class="n">_jsThread</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">[</span><span class="n">self</span> <span class="n">_tryAndHandleError</span><span class="o">:</span><span class="n">block</span><span class="p">];</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="p">[</span><span class="n">self</span> <span class="n">performSelector</span><span class="o">:</span><span class="k">@selector</span><span class="p">(</span><span class="n">_tryAndHandleError</span><span class="o">:</span><span class="p">)</span>
          <span class="nl">onThread:</span><span class="n">_jsThread</span>
          <span class="nl">withObject:</span><span class="n">block</span>
          <span class="nl">waitUntilDone:</span><span class="nb">NO</span><span class="p">];</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>除此之外还有个RCTMessageThread类，专门用于在js线程中执行c++的同步和异步函数。</p>
<h3>获取ModuleClass</h3>
<p><strong>[self _initModules:RCTGetModuleClasses() withDispatchGroup:prepareBridge lazilyDiscovered:NO]</strong>方法就是获取所有要暴露的类并做相应初始化。首先了解一下要将一个类暴露给JS需要怎么做。我们已RN里已经有的一个粘贴板类来看一下。</p>
<div class="highlight"><pre><span class="c1">//RCTClipboard.h</span>
<span class="k">@interface</span> <span class="nc">RCTClipboard</span> : <span class="nc">NSObject</span> <span class="o">&lt;</span><span class="n">RCTBridgeModule</span><span class="o">&gt;</span>

<span class="k">@end</span>

<span class="c1">//RCTClipboard.m</span>
<span class="k">@implementation</span> <span class="nc">RCTClipboard</span>

<span class="n">RCT_EXPORT_MODULE</span><span class="p">()</span>

<span class="o">-</span> <span class="p">(</span><span class="kt">dispatch_queue_t</span><span class="p">)</span><span class="n">methodQueue</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">dispatch_get_main_queue</span><span class="p">();</span>
<span class="p">}</span>


<span class="n">RCT_EXPORT_METHOD</span><span class="p">(</span><span class="n">setString</span><span class="o">:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="n">content</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">UIPasteboard</span> <span class="o">*</span><span class="n">clipboard</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIPasteboard</span> <span class="n">generalPasteboard</span><span class="p">];</span>
  <span class="n">clipboard</span><span class="p">.</span><span class="n">string</span> <span class="o">=</span> <span class="p">(</span><span class="n">content</span> <span class="o">?</span> <span class="o">:</span> <span class="s">@&quot;&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">RCT_EXPORT_METHOD</span><span class="p">(</span><span class="n">getString</span><span class="o">:</span><span class="p">(</span><span class="n">RCTPromiseResolveBlock</span><span class="p">)</span><span class="n">resolve</span>
                  <span class="nl">rejecter:</span><span class="p">(</span><span class="n">__unused</span> <span class="n">RCTPromiseRejectBlock</span><span class="p">)</span><span class="n">reject</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">UIPasteboard</span> <span class="o">*</span><span class="n">clipboard</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIPasteboard</span> <span class="n">generalPasteboard</span><span class="p">];</span>
  <span class="n">resolve</span><span class="p">((</span><span class="n">clipboard</span><span class="p">.</span><span class="n">string</span> <span class="o">?</span> <span class="o">:</span> <span class="s">@&quot;&quot;</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">@end</span>
</pre></div>


<p>其实主要关键点就是类需要实现协议RCTBridgeModule，并在implementation里加RCT_EXPORT_MODULE()。在要暴露的方法在其前面加宏RCT_EXPORT_METHOD修饰。注意这里不支持有返回值的方法，还有也可以暴露一些属性的，但是这里不展开说明。</p>
<p>RCTBridgeModule协议定义了+ (NSString *)moduleName这个必须实现的方法，还有其他可选方法和属性。
看一下RCT_EXPORT_MODULE()宏到底干了什么</p>
<div class="highlight"><pre><span class="cm">/**</span>
<span class="cm"> * Place this macro in your class implementation to automatically register</span>
<span class="cm"> * your module with the bridge when it loads. The optional js_name argument</span>
<span class="cm"> * will be used as the JS module name. If omitted, the JS module name will</span>
<span class="cm"> * match the Objective-C class name.</span>
<span class="cm"> */</span>
<span class="p">#</span><span class="n">define</span> <span class="no">RCT_EXPORT_MODULE</span><span class="p">(</span><span class="n">js_name</span><span class="p">)</span> \
<span class="no">RCT_EXTERN</span> <span class="k">void</span> <span class="n">RCTRegisterModule</span><span class="p">(</span><span class="n">Class</span><span class="p">);</span> \
<span class="o">+</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="n">moduleName</span> <span class="p">{</span> <span class="k">return</span> <span class="p">@#</span><span class="n">js_name</span><span class="p">;</span> <span class="p">}</span> \
<span class="o">+</span> <span class="p">(</span><span class="k">void</span><span class="p">)</span><span class="n">load</span> <span class="p">{</span> <span class="n">RCTRegisterModule</span><span class="p">(</span><span class="n">self</span><span class="p">);</span> <span class="p">}</span>
</pre></div>


<p>这个宏里实现moduleName方法，定义了RCT_EXTERN void RCTRegisterModule(Class)，还有实现了load方法，在load方法里调用了RCTRegisterModule方法。RCTRegisterModule实现是在RCTBridge.m里面。</p>
<div class="highlight"><pre><span class="k">static</span> <span class="n">NSMutableArray</span><span class="o">&lt;</span><span class="kt">Class</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">RCTModuleClasses</span><span class="p">;</span>
<span class="n">NSArray</span><span class="o">&lt;</span><span class="kt">Class</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">RCTGetModuleClasses</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">RCTModuleClasses</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Register the given class as a bridge module. All modules must be registered</span>
<span class="cm"> * prior to the first bridge initialization.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">RCTRegisterModule</span><span class="p">(</span><span class="kt">Class</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">RCTRegisterModule</span><span class="p">(</span><span class="kt">Class</span> <span class="n">moduleClass</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">static</span> <span class="kt">dispatch_once_t</span> <span class="n">onceToken</span><span class="p">;</span>
  <span class="n">dispatch_once</span><span class="p">(</span><span class="o">&amp;</span><span class="n">onceToken</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
    <span class="n">RCTModuleClasses</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSMutableArray</span> <span class="n">new</span><span class="p">];</span>
  <span class="p">});</span>

  <span class="n">RCTAssert</span><span class="p">([</span><span class="n">moduleClass</span> <span class="n">conformsToProtocol</span><span class="o">:</span><span class="err">@</span><span class="n">protocol</span><span class="p">(</span><span class="n">RCTBridgeModule</span><span class="p">)],</span>
            <span class="s">@&quot;%@ does not conform to the RCTBridgeModule protocol&quot;</span><span class="p">,</span>
            <span class="n">moduleClass</span><span class="p">);</span>

  <span class="c1">// Register module</span>
  <span class="p">[</span><span class="n">RCTModuleClasses</span> <span class="n">addObject</span><span class="o">:</span><span class="n">moduleClass</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>


<p>实际上就是讲Class对象加入到全局唯一的一个数组里。也就是说，当系统在加载这个类的时候，就将这个类对象加入到了一个数组里，后面只要从这个数组里取所有要暴露给JS的类就可以了。</p>
<p>再来看看怎么暴露方法。</p>
<div class="highlight"><pre><span class="cp">#define RCT_EXPORT_METHOD(method) \</span>
<span class="cp">  RCT_REMAP_METHOD(, method)</span>


<span class="cp">#define RCT_REMAP_METHOD(js_name, method) \</span>
<span class="cp">  _RCT_EXTERN_REMAP_METHOD(js_name, method, NO) \</span>
<span class="cp">  - (void)method;</span>


<span class="cp">#define _RCT_EXTERN_REMAP_METHOD(js_name, method, is_blocking_synchronous_method) \</span>
<span class="cp">  + (const RCTMethodInfo *)RCT_CONCAT(__rct_export__, RCT_CONCAT(js_name, RCT_CONCAT(__LINE__, __COUNTER__))) { \</span>
<span class="cp">    static RCTMethodInfo config = {#js_name, #method, is_blocking_synchronous_method}; \</span>
<span class="cp">    return &amp;config; \</span>
<span class="cp">  }</span>
</pre></div>


<p>这里的宏嵌套得让人眼花缭乱，在整个RN源码中运用了大量的宏，而且大多是高级用法，这个给阅读理解造成一定的困难。如果看不懂，最好先找专门的讲宏文章先看一看。这里主要作用就是声明了返回值为void的method方法，并且生成了一个以__rct_export__开头，包含了类名，行号等信息的为类名，返回值为RCTMethodInfo的类方法。这个方法主要是为后面生成配置信息用的。</p>
<p><strong>[self _initModules:RCTGetModuleClasses() withDispatchGroup:prepareBridge lazilyDiscovered:NO]</strong>主要代码是</p>
<div class="highlight"><pre><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">_initModules:</span><span class="p">(</span><span class="n">NSArray</span><span class="o">&lt;</span><span class="kt">id</span><span class="o">&lt;</span><span class="n">RCTBridgeModule</span><span class="o">&gt;&gt;</span> <span class="o">*</span><span class="p">)</span><span class="nv">modules</span>
   <span class="nl">withDispatchGroup:</span><span class="p">(</span><span class="kt">dispatch_group_t</span><span class="p">)</span><span class="nv">dispatchGroup</span>
    <span class="nl">lazilyDiscovered:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">lazilyDiscovered</span>
<span class="p">{</span>
<span class="p">....</span>
<span class="c1">// Set up moduleData for automatically-exported modules</span>
  <span class="n">NSArray</span><span class="o">&lt;</span><span class="n">RCTModuleData</span> <span class="o">*&gt;</span> <span class="o">*</span><span class="n">moduleDataById</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="n">registerModulesForClasses</span><span class="o">:</span><span class="n">modules</span><span class="p">];</span>
  <span class="p">......</span>
   <span class="p">[</span><span class="n">self</span> <span class="n">_prepareModulesWithDispatchGroup</span><span class="o">:</span><span class="n">dispatchGroup</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>


<p>registerModulesForClasses:方法主要是遍历RCTModuleClasses，为每个class生成一个RCTModuleData并在一个字典和数组里存起来后面使用。_prepareModulesWithDispatchGroup:就是检查每个RCTModuleData是否需要在主线程中创建实例，是的话，就创建实例存起来。</p>
<h3>准备JS相关类（JSCExecutor）</h3>
<p>在start方法里面，它实例化了Instance(_reactInstance)和一个JSExecutorFactory，然后在js线程中调用了_initializeBridge:方法。</p>
<div class="highlight"><pre><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">_initializeBridge:</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">JSExecutorFactory</span><span class="o">&gt;</span><span class="p">)</span><span class="nv">executorFactory</span>
<span class="p">{</span>
<span class="p">.....</span>
<span class="n">__weak</span> <span class="n">RCTCxxBridge</span> <span class="o">*</span><span class="n">weakSelf</span> <span class="o">=</span> <span class="n">self</span><span class="p">;</span>
  <span class="n">_jsMessageThread</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">RCTMessageThread</span><span class="o">&gt;</span><span class="p">([</span><span class="n">NSRunLoop</span> <span class="n">currentRunLoop</span><span class="p">],</span> <span class="o">^</span><span class="p">(</span><span class="n">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">[</span><span class="n">weakSelf</span> <span class="n">handleError</span><span class="o">:</span><span class="n">error</span><span class="p">];</span>
    <span class="p">}</span>
  <span class="p">});</span>
  <span class="p">.....</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">_reactInstance</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// This is async, but any calls into JS are blocked by the m_syncReady CV in Instance</span>
    <span class="n">_reactInstance</span><span class="o">-&gt;</span><span class="n">initializeBridge</span><span class="p">(</span>
      <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">RCTInstanceCallback</span><span class="o">&gt;</span><span class="p">(</span><span class="n">self</span><span class="p">),</span>
      <span class="n">executorFactory</span><span class="p">,</span>
      <span class="n">_jsMessageThread</span><span class="p">,</span>
      <span class="p">[</span><span class="n">self</span> <span class="n">_buildModuleRegistry</span><span class="p">]);</span>
      <span class="p">......</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>可以看到这里主要创建了一个RCTMessageThread，并将相关属性传给_reactInstance进行初始化。_reactInstance的初始化需要一个ModuleRegistry，ModuleRegistry里面有包含了所有的RCTNativeModule，而每个RCTNativeModule里又包含了一个RCTModuleData.即将前面生成的所有RCTModuleData传给了_reactInstance。</p>
<p>在Instance的初始化方法initializeBridge里，最主要是创建了NativeToJsBridge的实例。而NativeToJsBridge的构造函数里，主要是调用了executorFactory来创建一个JSCExecutor。JSCExecutor是一个相当重要的类，走到这里很不容易，跳转了很多层。这一块也是最不好理解的，基本上c++和OC互调，而且使用了很多c++11的特性，我很不熟悉。然后也使用了folly库，这个库也不是很好理解。所以我准备把剩下的东西放到下一篇文章来讲。</p>
<h2>参考资料</h2>
<p><a href="http://www.cocoachina.com/ios/20170720/19958.html">深入浅出 JavaScriptCore</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1004875">JavaScriptCore全面解析 （上篇）</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1004876">JavaScriptCore全面解析 （下篇）
</a></p>
<p><a href="https://www.jianshu.com/p/931367388a8d?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation">理解React-Native(0.46) 中native和js通信原理(iOS)</a></p>
<p><a href="http://blog.cnbang.net/tech/2698/">React Native通信机制详解</a></p>
<p>如果你觉得这篇文章有用，请打赏小钱喝杯咖啡^_^
<img alt="打赏" src="https://thumbnail0.baidupcs.com/thumbnail/2240a19cfdd74eaf4336b9135e9b58ae?fid=2199618804-250528-202867532336457&amp;time=1519200000&amp;rt=sh&amp;sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-bRRYVx1ok%2F1d5hW640dcK6Sd714%3D&amp;expires=8h&amp;chkv=0&amp;chkbd=0&amp;chkpc=&amp;dp-logid=1198971133580912478&amp;dp-callid=0&amp;size=c710_u400&amp;quality=100&amp;vuk=-&amp;ft=video" /></p><p class="subheader">Category: <a href="http://szuwest.github.io/category/ji-zhu.html">技术</a>

    Tagged: 
    <a href="http://szuwest.github.io/tag/reactnative-yuan-ma-ios.html">ReactNative 源码 iOS </a>
</p>



<p><a href="http://szuwest.github.io/react-nativekuang-jia-yuan-ma-xue-xi-iosshang.html#disqus_thread">comments</a></p>            </article>


                <hr  class="gradient"/>


        


            <article>
                <a href="http://szuwest.github.io/qian-tan-reactnativeji-zhu-de-you-lie.html"><h3 class="article-title">浅谈ReactNative技术的优劣</h3></a>
<h6 class="subheader" title="2018-02-06T00:00:00">2018-02-06
</h6>


<h1>浅谈ReactNative技术的优劣</h1>
<p>去年大概10月份开始使用ReactNative技术来开发项目，现在也已经有几个月时间了。也上线了三个ReactNative开发的项目。一直想谈谈使用ReactNative的开发感受。</p>
<ul>
<li>使用react-native确实可以提高界面开发效率，因为两个平台，只需要编写一套代码。react-native在这方面做了很多工作，让界面开发跟web开发基本一致。web开发人员可以很方便的写react-native界面，不需要二次学习。而且在react-native里面的像素是逻辑像素，可以比较好的适配界面。</li>
<li>react-native界面开发方式跟web开发是基本一致的，这跟native开发界面有很大不同。react-native界面开发是声明式开发，而且是继承于react框架，而纯native开发人员根本不了解这个框架，需要学习成本。它的View布局层次跟原生的布局层次不太一样。我自己也搞了挺久才搞清楚。</li>
<li>react-native很适合那些纯http数据交互的应用。即那些数据和内容都是从服务器拉取，APP只是展示和消费的场景应用。这样不但界面可以react-native来写，HTTP请求也可以很方便的用ReactNative来写。</li>
<li>react-native不适合用于那些需要复杂的通信方式的应用，也不适用于那些强多媒体资源的应用，例如要做相册，音视频播放的应用。因为react-native上不方便用socket的那些通信方法，需要自己封装。然后内存问题也不太好把控。对于相册，多媒体播放，ReactNative也没有封装。</li>
<li>react-native对于web转native开发是很有用，对纯native开发转react-native开发不是很友好，主要是思维方式发生比较大的变化。</li>
<li>react-native不能隔绝native开发的知识。要做APP开发，最终还是需懂得native开发的一些知识，react-native并不能完全屏蔽这些。一个纯web开发想要转react-native开发，还是需要懂native开发的人来帮助和指导，或者自己需要先学习native相关知识。</li>
</ul>
<h1>react-native开发会是未来的方向吗</h1>
<p>这个我也不敢说。不过ReactNative开发未来会代替掉一些native发 ...</p><p class="subheader">Category: <a href="http://szuwest.github.io/category/ji-zhu.html">技术</a>

    Tagged: 
    <a href="http://szuwest.github.io/tag/react-native.html">react-native </a>
</p>



<p><a href="http://szuwest.github.io/qian-tan-reactnativeji-zhu-de-you-lie.html#disqus_thread">comments</a></p>                <a class="button radius secondary small right" href="http://szuwest.github.io/qian-tan-reactnativeji-zhu-de-you-lie.html">Read More</a>
                <hr  class="gradient"/>
            </article>

        


            <article>
                <a href="http://szuwest.github.io/code-reviewfang-an.html"><h3 class="article-title">Code Review方案</h3></a>
<h6 class="subheader" title="2018-01-10T00:00:00">2018-01-10
</h6>


<h1>Code Review方案</h1>
<h2>定义</h2>
<p>Code Review代码评审是指在软件开发过程中，通过对源代码进行系统性检查的过程。通常的目的是查找各种缺陷，包括代码缺陷、功能实现问题、编码合理性、性能优化等；保证软件总体质量和提高开发者自身水平</p>
<h2>code review 的好处</h2>
<ul>
<li>
<ol>
<li>提高代码质量。</li>
</ol>
</li>
<li>
<ol>
<li>及早发现潜在缺陷，降低修改/弥补缺陷的成本。</li>
</ol>
</li>
<li>
<ol>
<li>促进团队内部知识共享，提高团队整体水平。</li>
</ol>
</li>
<li>
<ol>
<li>评审过程对于评审人员来说，也是一种思路重构的过程。帮助更多的人理解系统。</li>
</ol>
</li>
<li>
<ol>
<li>是一个传递知识的手段，可以让其它并不熟悉代码的人知道作者的意图和想法，从而可以在以后轻松维护代码。</li>
</ol>
</li>
<li>
<ol>
<li>鼓励程序员们相互学习对方的长处和优点。 </li>
</ol>
</li>
<li>
<ol>
<li>可以被用来确认自己的设计和实现是一个清楚和简单的。</li>
</ol>
</li>
</ul>
<h2>code review形式</h2>
<p>一般code review有两种形式，一种是代码评审会议，我称之为Code Review Meeting，就是将团队成员都组织起来开会，让代码Owner上去讲自己代码的实现和思路，其它人发表意见和进行讨论，也有把这种叫做team review。另外一种是一对一评审，我称之为Single Review，就是项目owner提交代码之后，让reviewer在空闲的时候帮忙评审代码，并且写出批注，owner收到批注后，进行修改或者回复 ...</p><p class="subheader">Category: <a href="http://szuwest.github.io/category/ji-zhu.html">技术</a>

    Tagged: 
    <a href="http://szuwest.github.io/tag/codereview.html">codereview </a>
</p>



<p><a href="http://szuwest.github.io/code-reviewfang-an.html#disqus_thread">comments</a></p>                <a class="button radius secondary small right" href="http://szuwest.github.io/code-reviewfang-an.html">Read More</a>
                <hr  class="gradient"/>
            </article>

        


            <article>
                <a href="http://szuwest.github.io/android-soku-jia-gu-jia-ke-fang-an.html"><h3 class="article-title">Android so库加固加壳方案</h3></a>
<h6 class="subheader" title="2018-01-06T00:00:00">2018-01-06
</h6>


<h1>Android so库加固加壳方案</h1>
<p>Android应用主要包含资源文件和代码，而代码一般包括Java代码和C/C++代码。Java代码编译后会生成dex文件，而C/C++编译后会生成so文件。Android应用的保护，主要对编译后的dex文件和so文件来保护，防止被别人反编译查看到里面的核心代码和逻辑。</p>
<p>对于Java代码，一般在编译时做代码混淆，编译后的文件名，函数名和变量名会变成一些无意义的名字，这个即使代码被反编译出来，也很难读懂。不过由于调用关系和逻辑都还在，花些时间还是有可能读懂。所以就有了一些防止反编译的方法出现。这就包括了dex加壳或者加密方法。对dex文件保护的方法现在有不少成熟的方案，有不少第三方公司免费提供加固方案。</p>
<p>对于C/C++代码的保护方案，会比Java代码的更麻烦一下。C/C++经过编译后生成so文件，这个so文件同样会能被反编译。由于我们的主要算法都采用C/C++来实现，并生成so文件提供给合作方使用，我们重点说的是C/C++代码和so文件的保护。</p>
<p>对于so文件的保护，可分为有so源代码和无so源码的情况。</p>
<h2>有源码保护</h2>
<p>针对有源代码的情况，可以大致分为代码混淆，Section或者函数加密。</p>
<h3>代码混淆</h3>
<p>代码混淆最简单的方法就是利用宏定义混淆函数名。例如通过一个宏定义把一个有意义的函数名变为一个无意义的字母组合，在编译后有意义的函数名就被替换为无意义的字母组合 ...</p><p class="subheader">Category: <a href="http://szuwest.github.io/category/android.html">Android</a>

    Tagged: 
    <a href="http://szuwest.github.io/tag/dong-hua-jia-gu-jia-ke.html">动画 加固 加壳 </a>
</p>



<p><a href="http://szuwest.github.io/android-soku-jia-gu-jia-ke-fang-an.html#disqus_thread">comments</a></p>                <a class="button radius secondary small right" href="http://szuwest.github.io/android-soku-jia-gu-jia-ke-fang-an.html">Read More</a>
                <hr  class="gradient"/>
            </article>

        


            <article>
                <a href="http://szuwest.github.io/2017nian-zong-jie-he-2018nian-zhan-wang.html"><h3 class="article-title">2017年总结和2018年展望</h3></a>
<h6 class="subheader" title="2017-12-31T00:00:00">2017-12-31
</h6>


<h1>2017年总结和2018年展望</h1>
<p>已经过去的2017年发生了很多事，我想从工作，生活和投资三个角度去总结一下。</p>
<h2>工作</h2>
<p>我离开了工作3年多的迅雷，这是我第二次离开迅雷。这可以说是一个好的选择，也可以说是不好的选择。实际上我的离开不是说已经在迅雷呆够了，而是因为我的领导挖我过去他们公司。好的方面，当然工资涨了，跨入了AI行业，有老大罩着。不好的方面是创业公司，风险高很多，很有可能坐不起来或者倒闭，浪费时间。还有一个比较遗憾的是，离开了自己一直看好的产品项目，玩客云即将要发布了，自己却离开了。曾家自己很看好这个项目，也投入了不少精力，真心希望能成功的产品，却在黎明前离开了，有点遗憾。有得必有失，这个选择是好是坏还要待时间来验证。</p>
<p>今年来到新公司，倒是学到了一点新技术：ReactNative。以前它出来的时候，自己也去看了一下，没机会试试。现在在项目里用起来了。这个技术看起来也没那么神，但是也确实有不少好处。这些年感觉自己的技术进步慢了，终于年纪也来了，比不上刚毕业的年轻人了。我自己也担心自己未来路怎么走。我现在也没有答案，我知道自己需要不断探索和思考。自己要减少浪费一些无所谓的时间，多点时间花在家庭和工作上。</p>
<p>另外一点是进入了AI行业，发现这个行业泡沫确实巨大。现在的创业感觉跟4年前的创业完全不一样 ...</p><p class="subheader">Category: <a href="http://szuwest.github.io/category/sheng-huo.html">生活</a>

    Tagged: 
    <a href="http://szuwest.github.io/tag/zong-jie.html">总结 </a>
</p>



<p><a href="http://szuwest.github.io/2017nian-zong-jie-he-2018nian-zhan-wang.html#disqus_thread">comments</a></p>                <a class="button radius secondary small right" href="http://szuwest.github.io/2017nian-zong-jie-he-2018nian-zhan-wang.html">Read More</a>
                <hr  class="gradient"/>
            </article>

        


            <article>
                <a href="http://szuwest.github.io/wan-ke-yun-de-qian-shi-yu-chu-sheng.html"><h3 class="article-title">玩客云的前世与出生</h3></a>
<h6 class="subheader" title="2017-12-24T00:00:00">2017-12-24
</h6>


<h1>玩客云的前世与出生</h1>
<p>迅雷最近的股价波动很大，股价从最低点附近4美元到现在13美元附近，涨了3倍多，最高点甚至到27美元。只是短短几个月的时间，涨幅这么大，主要是因为玩客云和玩客币（现在叫链克）。对于玩客币，我自己不想说太多，但是对于玩客云这个产品，我是很有感情的。这个产品是我从头就开始参与开发，虽然我已经离开玩客云团队一段时间了，但是我还是想说说这个产品。知道这个产品前世与今生的人，其实真的不是很多。我想说一说这个产品，也算是对自己的一段总结。</p>
<p>不过我说的所有观点都是我个人观点，跟玩客云团队无关，特此声明。</p>
<h2>玩客云的出生</h2>
<p>玩客云是有网心科技出品的一款智能硬件产品，主打个人云盘功能，充当CDN节点功能，后来也又加入玩客币功能。玩客云这个项目最初的时候并不叫玩客云，内部我们叫赚钱宝3代。它是迅雷下载宝和赚钱宝的合并的一个产品。实际上 玩客云=迅雷下载宝+赚钱宝+玩客币 这样的一个产品。所以在做玩客云的时候，下载宝和赚钱宝这两个项目已经停了，然后团队合并成新的团队：玩客云团队。而这个团队的绝大部分人，都是下载宝团队的人，下载宝整个项目就是这样从迅雷总部并入网心科技的。玩客云的前身就是迅雷下载宝。</p>
<p>玩客云的最初立项是在3，4月份，从一开始老板就非常重视整个项目。我们内部叫赚钱宝3代，但是我们一直在想给他一个新的名字 ...</p><p class="subheader">Category: <a href="http://szuwest.github.io/category/chan-pin.html">产品</a>

    Tagged: 
    <a href="http://szuwest.github.io/tag/xun-lei-wang-xin-chao-ji-ying-pan-xun-lei-xia-zai-bao-zhuan-qian-bao-wan-ke-yun.html">迅雷 网心 超级硬盘 迅雷下载宝 赚钱宝 玩客云 </a>
</p>



<p><a href="http://szuwest.github.io/wan-ke-yun-de-qian-shi-yu-chu-sheng.html#disqus_thread">comments</a></p>                <a class="button radius secondary small right" href="http://szuwest.github.io/wan-ke-yun-de-qian-shi-yu-chu-sheng.html">Read More</a>
                <hr  class="gradient"/>
            </article>

        


            <article>
                <a href="http://szuwest.github.io/shou-ji-ju-yu-wang-nei-bao-gua-re-dian-fa-xian-he-zu-wang-tong-xun-shi-xian.html"><h3 class="article-title">手机局域网内（包括热点）发现和组网通讯实现</h3></a>
<h6 class="subheader" title="2017-11-05T00:00:00">2017-11-05
</h6>


<h1>手机局域网内（包括热点）组网通讯实现</h1>
<p>最近在做一个应用，需要多个手机一起组网，一个充当主机，其他多个手机充当从机。主机跟每个从机之间可以相互通信，发送消息和文件。这不就是个CS（client-server）模式吗，只不过server不是在云端，只是在同一个局域网的手机上罢了。</p>
<p>这里面有两个关键的地方，一个是如何发现同一个局域网内的手机客户端，包括自建的热点，一个是知道各个手机的Ip地址后，用什么方式来建立通信。这里说一下热点，手机开启热点之后，别的手机连上这个特点，其实也是一个小型局域网，只不过这个局域网稍微有点不一样（Ip地址），其他的都一样。</p>
<h2>局域网发现</h2>
<p>局域网发现主要难点在于如何得到对方Ip地址。我们的做法是发送UDP包。UDP协议是无面向连接的，也就是不需要像TCP协议那样提前建立连接。所以我们向局域网内某一个特定的端口广播UDP包，接收到这个包的人，发送回包，那么我们就知道彼此的存在和地址。</p>
<p>那么关键地方是</p>
<ul>
<li>有人一直在监听一个端口X，接收UDP包</li>
<li>有人在一直往这个端口X发送UDP包</li>
</ul>
<p>监听端的人收到了UDP包后，就知道了发送者的Ip地址。但这时发送者是不知道接收者的，因为这是UDP包，无连接的状态的。那怎么做才让发送者也知道了。其实只要发过来再做一次就行。发送者同时也是监听者，这就行了。不过发送者A监听的是另一个端口Y，接收者B接收到包后 ...</p><p class="subheader">Category: <a href="http://szuwest.github.io/category/ji-zhu.html">技术</a>

    Tagged: 
    <a href="http://szuwest.github.io/tag/ju-yu-wang-re-dian-tong-xun-yan-bo-websocket.html">局域网 热点 通讯 广播 WebSocket </a>
</p>



<p><a href="http://szuwest.github.io/shou-ji-ju-yu-wang-nei-bao-gua-re-dian-fa-xian-he-zu-wang-tong-xun-shi-xian.html#disqus_thread">comments</a></p>                <a class="button radius secondary small right" href="http://szuwest.github.io/shou-ji-ju-yu-wang-nei-bao-gua-re-dian-fa-xian-he-zu-wang-tong-xun-shi-xian.html">Read More</a>
                <hr  class="gradient"/>
            </article>

        


            <article>
                <a href="http://szuwest.github.io/sheng-wen-shi-bie-zhi-androidshou-ji-lu-yin-cai-ji-tan-tao.html"><h3 class="article-title">声纹识别之Android手机录音采集探讨</h3></a>
<h6 class="subheader" title="2017-10-08T00:00:00">2017-10-08
</h6>


<h1>声纹识别之Android手机录音采集探讨</h1>
<p>声纹识别是人工智能语音方向的一个重要分支。最近人工智能的兴起也带动了声纹识别这一领域的发展。声纹识别也越来越准确。不过在声音采集方面，特别是手机端的声音采集，是一个很讲究的问题。我加入人工智能声纹识别公司也有两个多月了，对手机端的语音采集也有了一定的了解，准备整理一下做成文章，跟大家探讨。今天重点说Android手机的录音采集方面的东西。</p>
<h2>语音采集的一些基础指标</h2>
<p>首先要搞清楚的一点是我们的人声是一些声波，是模拟信号，我们计算机的采集是将这些模拟信号转化为数字信号存储起来。我们播放语音文件的时候，是将数字信号转化为模拟信号。说实话，这一块的知识我大学也学得不好，模电我们软件工程的学生没有专门的课程，数电倒是有。不过数电模电的转化这个概念这倒不难理解。这里面就涉及到了采样率和采样位数这两个指标。</p>
<ul>
<li>采样率，或者叫采样频率，指每秒钟取得声音样本的次数。采样率越高，数据越精确。我们也需要了解常用的采样率是多少：8k(8000），16k, 44.1k,48k。8k是电话所用的采样率，对于我们人说的声音的频率，基本在这个采样率之内。所以电话就才采用这个频率采样。48k采样率是CD，DVD所采用的。超过这个频率人耳是分辨不出来的了。</li>
<li>采样位数，说的是每个采样数据占的位数。每个采样数据记录的是振幅, 采样精度取决于采样位数的大小。常用的位数是8位，也就是一个字节。还有16位或者32位 ...</li></ul><p class="subheader">Category: <a href="http://szuwest.github.io/category/ji-zhu.html">技术</a>

    Tagged: 
    <a href="http://szuwest.github.io/tag/sheng-wen-shi-bie-ren-gong-zhi-neng-lu-yin-android.html">声纹识别 人工智能 录音 Android </a>
</p>



<p><a href="http://szuwest.github.io/sheng-wen-shi-bie-zhi-androidshou-ji-lu-yin-cai-ji-tan-tao.html#disqus_thread">comments</a></p>                <a class="button radius secondary small right" href="http://szuwest.github.io/sheng-wen-shi-bie-zhi-androidshou-ji-lu-yin-cai-ji-tan-tao.html">Read More</a>
                <hr  class="gradient"/>
            </article>

        


            <article>
                <a href="http://szuwest.github.io/gua-pei-ios11yu-iphone-xxu-yao-zhu-yi-shi-xiang.html"><h3 class="article-title">适配iOS11与iPhone X需要注意事项</h3></a>
<h6 class="subheader" title="2017-09-26T00:00:00">2017-09-26
</h6>


<h1>适配iOS11与iPhone X需要注意的事项</h1>
<p>最近苹果发布了iOS11和iPhone X，我之前开发的一个应用界面出现了问题，然后需要适配。记录一下需要注意的事项。</p>
<h2>适配iOS11</h2>
<p>第一个问题是iOS11导航栏改变了。除了加入largeTitle这种特性以外，还改变了很多东西，可以说是完全重写了导航栏。我遇到的问题是导航栏返回按钮图片变得很大，巨丑无比，所以得看看什么原因。</p>
<ul>
<li>我看了下我导航栏的设置代码，还做了挺多事，而且做了很多hack。第一是通过 <strong>[UINavigationBar appearance].backIndicatorImage</strong> 和 <strong>[UINavigationBar appearance].backIndicatorTransitionMaskImage</strong>设置了返回按钮图片，还有 </li>
</ul>
<div class="highlight"><pre><span class="p">[[</span><span class="n">UIBarButtonItem</span> <span class="n">appearance</span><span class="p">]</span> <span class="n">setBackButtonTitlePositionAdjustment</span><span class="o">:</span><span class="n">UIOffsetMake</span><span class="p">(</span><span class="n">NSIntegerMin</span><span class="p">,</span> <span class="n">NSIntegerMin</span><span class="p">)</span> <span class="n">forBarMetrics</span><span class="o">:</span><span class="n">UIBarMetricsDefault</span><span class="p">];</span>
</pre></div>


<p>设置了把返回按钮右边的文字隐藏掉。还有通过hack 方式找到 _UINavigationBarBackIndicatorView把它的frame给改了。</p>
<p>因为iOS11的导航栏变化很大，_UINavigationBarBackIndicatorView这个类找不到了，所以frame修改就失败了。然后因为我发现我设置的返回按钮的那种图片本来是很大，因为设置了frame把它缩小了。而现在frame已经设置不了，所以就按图片原本的大小显示了。最后解决办法就是把图片大小设置成符合导航栏的大小。</p>
<p>图片大小是正常了，但是还是有别问题 ...</p><p class="subheader">Category: <a href="http://szuwest.github.io/category/ji-zhu.html">技术</a>

    Tagged: 
    <a href="http://szuwest.github.io/tag/ios11-iphonex.html">iOS11 iPhoneX </a>
</p>



<p><a href="http://szuwest.github.io/gua-pei-ios11yu-iphone-xxu-yao-zhu-yi-shi-xiang.html#disqus_thread">comments</a></p>                <a class="button radius secondary small right" href="http://szuwest.github.io/gua-pei-ios11yu-iphone-xxu-yao-zhu-yi-shi-xiang.html">Read More</a>
                <hr  class="gradient"/>
            </article>

        


            <article>
                <a href="http://szuwest.github.io/coturnzai-iosduan-ying-yong-he-libeventde-bian-yi.html"><h3 class="article-title">Coturn在iOS端应用和libevent的编译</h3></a>
<h6 class="subheader" title="2017-07-02T00:00:00">2017-07-02
</h6>


<h1>Coturn在iOS端应用和libevent的编译</h1>
<p>coturn是一个Google的开源库，用于客服端-服务器-客户端之间建立数据通道，传输数据流。现在直播所有的技术WebRTC就是基于coturn的。这个技术真的很牛。</p>
<p>我们的产品个人私有云，一款智能硬件，接上你的硬盘，就可以通过手机消费你硬盘里的文件，任务时候任何地方，只要你联网。从智能盒子和手机之间的数据传输就需要coturn这种技术。WebRTC很好，但是不适用于智能硬件.</p>
<p>Coturn依赖的库有libevent和OpenSSL。OpenSSL有很多iOS的库，使用也很广泛。libevent也是一个使用挺多的C库，但是在移动平台上很少用。我在iOS平台上编译libevent遇到了很多问题。一个是不能直接用同时用在真机和模拟器上，一个是iOS10以下系统会闪退。第一个问题比较好解决，但是第二个问题不太好解决。我一直以为是我编译的库有问题，后来另一个同事他把崩溃堆栈发给我看，我发现是iOS9的系统库缺少一个get_clocktime的函数。经过搜索，发现是libevent确实是有这个东西，也有人遇到同样的问题。可以通过一个编译参数来禁用掉。</p>
<p>下面是libevent的编译脚本主要内容</p>
<div class="highlight"><pre>###########################################################################
# Choose your libevent version and your currently-installed iOS SDK version:
#
VERSION=&quot;2.1.8-stable&quot;
USERSDKVERSION=&quot;10.3 ...</pre></div><p class="subheader">Category: <a href="http://szuwest.github.io/category/ji-zhu.html">技术</a>

    Tagged: 
    <a href="http://szuwest.github.io/tag/ios-coturn-libevent.html">iOS Coturn libevent </a>
</p>



<p><a href="http://szuwest.github.io/coturnzai-iosduan-ying-yong-he-libeventde-bian-yi.html#disqus_thread">comments</a></p>                <a class="button radius secondary small right" href="http://szuwest.github.io/coturnzai-iosduan-ying-yong-he-libeventde-bian-yi.html">Read More</a>
                <hr  class="gradient"/>
            </article>

            <!-- /#posts-list -->
<div class="pagination-centered">
<h6 class="subheader">Page 1 of 5</h6>

<p>

        <a href="http://szuwest.github.io/author/west2.html">Next &raquo;</a>
</p>
</div>

    </div>
    <!-- End Main Content -->

    <!-- Sidebar -->
    <aside class="large-3 columns">
        <h5 class="sidebar-title">Site</h5>
        <ul class="side-nav">
            <li><a href="http://szuwest.github.io/archives.html">Archives</a>
            <li><a href="http://szuwest.github.io/tags.html">Tags</a>


        </ul>

		
        <h5 class="sidebar-title">Categories</h5>
        <ul class="side-nav">
            <li><a href="http://szuwest.github.io/category/android.html">Android</a></li>
            <li><a href="http://szuwest.github.io/category/bian-cheng-jia-gou.html">编程架构</a></li>
            <li><a href="http://szuwest.github.io/category/chan-pin.html">产品</a></li>
            <li><a href="http://szuwest.github.io/category/ios.html">iOS</a></li>
            <li><a href="http://szuwest.github.io/category/ji-zhu.html">技术</a></li>
            <li><a href="http://szuwest.github.io/category/sheng-huo.html">生活</a></li>
            <li><a href="http://szuwest.github.io/category/suan-fa.html">算法</a></li>
   
        </ul>

        <h5 class="sidebar-title">Links</h5>
        <ul class="side-nav">
            <li><a href="http://szuwest.github.io/pages/about.html">About</a></li>
            <li><a href="http://szhanfeng203.blog.163.com/">我的生活博客</a></li>
            <li><a href="http://szuwest.github.io/feeds/all.atom.xml">RSS</a></li>
        </ul>
		
        <h5 class="sidebar-title">Social</h5>
        <ul class="side-nav">
            <li><a href="https://github.com/szuwest">Github</a></li>
            <li><a href="https://twitter.com/szuwest">Twitter</a></li>
            <li><a href="https://www.facebook.com/profile.php?id=1084651913">Facebook</a></li>
            <li><a href="http://weibo.com/szuwest">微博</a></li>
        </ul>

    </aside> <!-- End Sidebar -->

</div> <!-- End Main Content and Sidebar -->


<!-- Footer -->
<footer class="row">
    <div class="large-12 columns">
        <hr />
        <div class="row">
            <div class="large-6 columns">
                <p>West's blog by West</p>
            </div>
            </div>
    </div>
    <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-55687145-1']);
    _gaq.push(['_trackPageview']);
    (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
    </script>
</footer>